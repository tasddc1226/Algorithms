# 빠른 정렬 알고리즘
quickSort(A[], low, high)
// 배열 A[low..high]를 빠른 정렬을 이용하여 정렬한다.
// 입력 : 정렬할 수 있는 요소들의 배열 A[low..high]
// 출력 : 오름차순으로 정렬된 요소들의 배열 A[low..high]
if (low < high){
    s = partition(A, low, high) // 기준 요소 A[low]를 기준으로 분할
    quickSort(A, low, s-1) // 왼쪽 부분을 퀵 정렬
    quickSort(A, s+1, high) // 오른쪽 부분을 퀵 정렬
}

// 최초 호출 : quickSort(A, 0, n-1)

# 분할 알고리즘
partition(A[], low, high){
// 입력 : 배열 A[0..n-1] 의 부분 배열 A[low..high], low < high
// 출력 : A[low..high]의 분할 후 기준 요소의 최종 위치(지수)를 반환
    i = low + 1
    j = high
    while ( i<= j ){
        if (A[i] <= A[low]) i = i + 1
        else if (A[j] > A[low]) j = j - 1
        else { 
            // 두개의 값을 교환.
            A[i] <-> A[j]
            i = i + 1
            j = j - 1
        }
    }
    A[low] <-> A[j]
    return j
}

# 분할 정복이 부적절한 경우
문제가 분할될 때마다 분할된 부분 문제들이 입력 크기의 합이
분할되기 전의 입력 크기보다 매우 커지는 경우.

경우 1 : 크기 n인 문제가 거의 n에 가까운 크기의 2개 이상의 부분 문제들로 분할될 때.

경우 2 : 크기 n인 문제가 n/c크기의 거의 n개의 부분문제 들로 분할될 때. C는 상수.

분할 정복이 부적절한 대표적인 문제 : 토끼 문제 (피보나치 수열.)

# 재귀 알고리즘
F(n)
// n번째 피보나치 수 f(n)을 분할 정복 기법을 이용하여 계산.
// 입력 : 양의 정수 n
// 출력 : n번째 피보나치 수 fn
if (n <= 1) return 1
else return F(n-1) + F(n-2)
주. 시간복잡도 : Theta(1.618^n) => 지수시간 알고리즘.

문제가 분할될 때마다 분할된 부분문제의 입력 크기의 합이 분할되기 전의 입력 크기보다
매우 커지게 된다.

# 동적 계획 알고리즘 
F_DP(F[], n)
// n번째 피보나치 수 fn을 동적 계획을 이용하여 계산.
// 입력 : 양의 정수 n, 크기 n의 배열 F[0..n-1]
// 출력 : n번째 피보나치 수 fn
F[0] = 1
F[1] = 1
for (i = 2; i < n; i++)
    F[i] = F[i-1] + f[i-2] <-- 기본 연산.
// F[n]이 구하는 답이다.
주. 시간복잡도 : n-1 : Theta(n)

# 분할 정복 기법 요약
- 균형 취하기 발견법을 적용한 분할 정복은 부분 문제들이 독립적이라면 (중복 계산이 없다면)
유용한 기법이다. 예) 최댓값과 최솟값 찾기, 합병 정렬, 빠른 정렬
- 피보나치 문제는 부분 문제들이 독립적이지 않은 예이다.
- 대게 분할 또는 합병 단계 중 하나가 쉽다.
- 문제는 보통 2개의 부분문제들로 나뉘어지나 항상 그렇지는 않다.
예) 이진 탐색은 1개의 부분 문제로 분할.



----------------------------------------------
quiz 4
1. 숫자들의 배열 <68, 25, 74, 61, 13, 80>을 빠른 정렬 알고리즘을 사용하여
오름차순으로 정렬하려고 한다. 빠른 정렬 알고리즘이 진행되는 과정을 단계적으로 보여라.
각 단계에서는 배열 내에 있는 요소들의 값들이 서로 교환될 때마다 한 단계로 나타내야 한다.
각 단계에서는 배열에 저장되어 있는 값들을 모두 보여주어야 한다.

i = 1 (배열의 1번째 요소 인덱스)
j = 5 (배열의 끝 요소 인덱스)

기준 요소 : 68  
25와 68을 비교 25 < 68 이므로 i값 증가.
80과 68을 비교 80 > 68 이므로 j값 감소
74와 68을 비교 68 < 74 이고 13과 68을 비교 13 < 68 이므로 13과 74의 위치를 바꾼다.
1. [68, 25, 13, 61, 74, 80]
그 후 i값과 j값 1 감소
61 < 68 이므로 i값과 j값 감소.
i < j가 되므로 68과 61을 바꾼다.

2. [61, 25, 13, 68, 74, 80]
그러면 68을 기준으로 왼쪽에는 68보다 작은값, 오른쪽에는 68보다 큰 값으로 정렬되었다.

[61, 25, 13] 에서 기준요소 : 61로 하면
25 < 61이므로 i값 찾음
13 < 61 이므로 j값 찾음.
25과 13을 교환한다.
3. [61, 13, 25]

이후 i와 j값을 감소하면 i<j가 되므로 기준값과 교체하면
4. [13, 25, 61]로 정렬됨.

5. [74, 80] 에서 기준요소 : 74
74 < 80 이므로 i값 증가, j값 감소
i < j이므로 해당 부분 배열은 정렬완료

6. 두 부분배열을 합친다.
[13, 25, 61, 68, 74, 80]으로 오름차순 정렬 완료

<68, 25, 74, 61, 13, 80>
1. 초기 pivot: 68 -> 68 25 74 61 13 80 [74, 13] swap
2. pivot: 68 -> 68 25 13 61 74 80 [68, 61] swap
3. pivot: 61 -> 61 25 13 68 74 80 [61,13] swap
4. 결과 : 13 25 61 68 74 80

