# 3주차 강의 요약
- 알고리즘의 효율성은 주로 시간복잡도로 나타냄
- 시간복잡도 : 알고리즘의 기본 연산 횟수를 입력 크기에 대한 함수로 표현
- 알고리즘의 복잡도 분류 : 최악/최선/평균 경우 복잡도

# 분할 정복 설계 전략
1. 분할 단계 (Divide)
- 문제를 같은 유형의 여러 개의 더 작은 부분 문제들로 나눈다.
- 부분 문제는 풀기 쉬울 때까지 계속 나눈다.

2. 정복 단계 (Conquer)
- 부분 문제들을 보통 재귀적으로 해결하여 해를 구한다.

3. 합병 단계 (Merge)
- 문제에 대한 해를 구하기 위해 부분 문제들의 해를 합친다.

# 최댓값과 최솟값 찾기
문제 : 크기가 n인 배열내의 요소들 중 최댓값과 최솟값을 찾는다.
ex ) 교실 내의 학생들 중에서 키가 가장 큰 학생과 가장 작은 학생을 찾는다.

쉬운 전략
1. 최댓값을 찾는다.                    비교 횟수 : n-1
2. 남은 배열 요소들의 최솟값을 찾는다.  비교 횟수 : n-2

    총 비교 횟수 = (n-1) + (n-2) = 2n -3

# 분할 정복 전략
1. 배열을 반으로 나눈다.
2. 양쪽 절반들의 최댓값과 최솟값을 찾는다.
3. 2에서 찾은 두 개의 최댓값들과 두 개의 최솟값들을 비교하여 전체 배열의
최댓값과 최솟값을 구한다.

# 최댓값과 최솟값 찾기 알고리즘
```cpp
findMaxMin(A[], i, j, min, max)
// A[i..j]의 최댓값과 최솟값을 찾는다
// input : 배열 A[i..j]
// output : min(최솟값), max(최댓값)
if (i = j) {min = A[i]; max = A[i]}
else if (i = j - 1) {
    if (A[i] < A[j]){
        min = A[i];
        max = A[j];
    } else {
        min = A[j];
        max = A[i];
    }
} else { // 3개 이상의 요소들의 배열일 때
    mid = (i+j) / 2 // 중간 요소의 지수를 구함.
    findMaxMin(A, i, mid, min1, max1)
    findMaxMin(A, mid+1, j, mid2, max2)

    if (min1 < min2){
        min = min1
    } else {
        min = min2
    }
    if (max1 < max2) {
        max = max2
    } else {
        max = max1
    }
}
```
> 최초 호출 : findMaxMin(A, 0, n-1, min, max) \
> 비교 횟수 : 2 X (n/2 -1) + n/2 = 3n/2 - 2 \
> 시간복잡도 : Θ(n)

# 합병 정렬
> 쉬운 전략
1. 최솟값을 찾는다.
2. 남은 요소들을 같은 방법으로 사용하여 재귀적으로 정렬한다.

> 분석 - 비교 횟수 : (n-1) + (n-2) + ... + 2 + 1 = n(n-1)/2
점근적 표기 : Θ(n^2)

> '균형 취하기 발견법' 사용 안함.
- 크기 k, 1 <= k <= n,의 배열을 크기 1의 부분 배열 (최솟값 요소)과
크기 (k-1)의 부분 배열(최솟값 요소를 제외한 남은 요소들)로 나눈다.
그러니까 나누긴 나누는데 크기가 차이가 난다는 뜻이다. 크기를 거의 같게 해서
나누어야 바람직하다.

# 합병 정렬의 분할 정복 전략
1. 배열을 반으로 나눈다.
2. 왼쪽 반과 오른쪽 반을 각각 정렬한다.
3. 정렬된 왼쪽 반과 오른쪽 반을 합병한다.

# 합병 정렬 알고리즘
```cpp
algorithm MergeSort(A[], low, high)
// 배열 A[low... high]를 합병 정렬을 이용하여 정렬한다.
if (low < high){
    mid = (low+high)/2
    MergeSort(A, low, mid)
    MergeSort(A, mid+1, high)
    Merge(A, low, mid, high)
}
```
> 최초 호출 : MergeSort(A, 0, n-1)

# 합병 알고리즘
- 임시 저장을 위해 다른 배열을 사용한다.
- 크기가 m인 부분과 크기가 n인 부분의 합병 : m + n - 1 번의 비교(최악의 경우)

```cpp
// 정렬된 부분 배열 A[low..mid]와 A[mid+1..high]를 합병한다.
알고리즘 Merge(A[], low, mid, high){
    // 크기가 (high + 1)인 배열 B를 만든다.
    h = low; // 새로운 배열의 시작 지수
    i = low; // 왼쪽 반의 시작 지수
    j = mid + 1; // 오른쪽 반의 시작 지수

    while (i <= mid && j <= high){
        if (A[i] <= A[j]){
            B[h] = A[i];
            i = i + 1;
        } else {
            B[h] = A[j];
            j = j + 1;
        }
        h = h + 1;
    }

    if ( i > mid ) { // 왼쪽 반의 배열에서 i가 mid 보다 커진 경우
        for ( k = j; k <= high; k++ ){ // j부터 high까지 있는 요소들을 그대로 B 배열에 넣음.
            B[h] = A[k];
            h = h + 1;
        }
    } else { // j > high 인 경우
        for ( k = i; k <= mid; k++ ){
            B[h] = A[k];
            h = h + 1;
        }
    }
    for ( k = low; k <= high; k++ ){
        A[k] = B[k];
    }
}
```

# 합병 알고리즘 시간 복잡도 분석
- T(n) : n개의 배열 요소들을 정렬하기 위해 필요한 비교 횟수
- T(n) = 2 * T(n/2) + n - 1 (n >= 2) 
- T(1) = 0 : 1개의 배열은 그 자체로 정렬되어있기 때문에 비교 횟수 X

> 2 * T(n/2) : 크기가 반인 두 배열을 재귀적으로 정렬하는데 필요한 비교 횟수 \
> n - 1 : Merge 하기 위해 최악의 경우에 필요한 비교 횟수

# 비재귀 합병 정렬 알고리즘
```cpp
MergeSort2(A[], n)
// 배열 A[0 .. n-1]를 비재귀 합병 정렬을 이용하여 정렬
size = 1
while (size < n) {
    for (i = 0; i < n; i = i + 2 * size)
        Merge(A, i, i + size - 1, i + 2 * size - 1)
    size = size * 2
}
```
> 분석 : Θ(log n) 단계 \
>        각 단계는 Θ(n) 비교가 필요함. \
>        따라서 비교 횟수는 Θ(nlog n)이다.

# 합병 정렬의 단점
- 합병 정렬의 공간 복잡도 : O(n)
- 입력을 위한 메모리 공간 (입력 배열) 외에 추가로 입력과 같은 크기의 공간 (임시 배열)이 별도로 필요함.
- 2개의 정렬된 부분을 하나로 합병하기 위해 합병된 결과를 저장할 공간이 필요하기 때문이다.

# 합병 정렬의 응용
- 외부 정렬의 기본이 되는 정렬 알고리즘
- 연결 목록에 있는 데이터를 정렬할 때에도 빠른 정렬이나 힙 정렬 보다 훨씬 효율적
- 멀티코어 CPU와 다수의 프로세서로 구성된 그래픽 처리 장치(GPU)의 등장으로 정렬 알고리즘을 병렬화 하기 위해 합병 정렬 알고리즘이 활용된다.


---

# 분할 정복 알고리즘
- 최댓값 찾기

```cpp
int arr[] = {6, 2, 9, 8, 1, 4, 17, 5}; 
public int max(int[] arr, int low, int high) {
    int m, left, right;
    m = (low + high) / 2;
    if(low == high) return arr[low];

    left = max(arr, low, m);
    right = max(arr, m + 1, high);
    
    return (left > right)?left:right;
}
```
- 최댓값 찾기 구현
```c
#include <stdio.h>

int a[10] = {3, 6, 1, 5, 100, 3, 3, 5, 9, 5};

int findMax(int low, int high) {
    if (low == high) return a[low];
    else {
        int m = (low + high) / 2;
        int left_max = findMax(low, m);
        int right_max = findMax(m+1, high);

        return left_max > right_max ? left_max : right_max;
    }
}

int main(void) {
    int Max = findMax(0,9);
    printf("MAX : %d\n", Max);

    return 0;
}

```