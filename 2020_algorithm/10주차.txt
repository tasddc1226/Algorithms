알고리즘 10주차 - 탐욕 알고리즘 (계속)
# 최소 비용 신장 트리 찾기 - 간선 지향 전략
1. 그래프에 남아있는 가장 가중치가 작은 간선을 선택
2. 선택된 간선이 합쳐진 두 개의 정점들 사이에 있다면
그 간선을 버리고 아니면 최소 비용 신장 트리에 추가한다.
3. (n-1) 개의 간선들이 추가될 때까지 과정 1, 2를 반복한다.

# 크루스칼 알고리즘
// e : 그래프의 간선들의 수
간선들의 가중치 순서로 오름차순으로 정렬하여 배열
EDGELIST[1...e] 에 저장한다.
T = {0} // 공집합
ecount = 0 // 최소 비용 신장 트리에 추가된 간선들의 수
k = 0  // 처리된 간선들의 수
while (ecount < n-1){
  k = k + 1
  (v, w) = EDGELIST[k]
  if (not together(v, w)) { // 합쳐지지 않았다면 수행
    T = T U { (v, w) }
    v와 w를 합친다.
    ecount = ecount + 1
  }
}

주 : together(v, w) : v와 w가 이미 합쳐졌으면 true이다.
분석 : (n-1)번의 통합과 최대 e번의 together를 수행한다.
정렬 시간 = O(elog e)

# 단일 출발점 최단 경로 찾기
문제 정의 : 
연결된 가중 그래프에서 한 특정 정점에서
다른 모든 정점으로 가는 최단 경로를 찾아라.

# 다익스트라 알고리즘
아이디어 : 출발 정점 v0부터 가까운 순서로 다른 정점들까지의
최단 경로를 찾는다.

진행 과정
- i번째 반복이 시작되기 전에 v0에 가장 가까운 (i-1)개의 정점
들까지의 최단 경로들을 찾았다.
- v0, 이 정점들과 최단 경로들 상의 간선들은 주어진 그래프의 부분 트리 Ti
를 형성한다.
- Ti 내에 있는 정점들에 인접한 '가장자리 정점'들 중에서 찾는다.
- 모든 가장자리 정점 u에 대해서 u에 인접한 트리 내의 정점 v까지의 거리,
W(u, v)와 출발 정점에서 v까지의 최단 경로의 길이, dv의 합을 계산한다.
- u에 인접한 트리 내의 정점들이 2개 이상인 경우에는 각 인접 정점에 대해
합을 계산한다. 그러한 합들 중 가장 작은 합을 갖는 가장자리 정점을 트리에 추가할
다음 정점으로 선택한다.

- 알고리즘
- n(>0) : 정점들의 수
- i, 0 <= i < n : 정점의 번호
- 출발 정점 : 0
- 정점 i에 d[i]와 p[i]를 저장한다.
  - d[i] : 출발 정점에서 각 정점까지의 최단 경로의 거리
    d[0] = 0
    d[i] = INF, i는 최단 경로 트리 내에 포함되지 않은 정점
  - p[i] : 출발 정점에서 각 정점까지의 최단 경로 상의 마지막에서 두 번째 정점
           (트리에서 부모 노드)의 번호 i = 0혹은 트리안에 포함되지 않은 정점이면
           p[i] = -1
- 주어진 그래프는 인접행렬 w 로 나타낸다.

1 T = {0} // 트리에 포함된 정점들의 집합을 공집합으로 초기화한다
2 for (i=0; i<n; i++) { 
3   d[i] = INF         // 정점 i의 최단 거리를 INF로 초기화.
4   p[i] = -1 }        // 정점 i의 부모 노드를 -1(없음)으로 초기화
5 d[0] = 0             // 출발 정점 0 의 최단 거리는 0으로 초기화
6 while ( |T| < n ) { // 트리에 포함된 정점들의 개수가 n보다 작으면 반복
7   T에 포함되지 않은 정점들 중에서 배열 d의 요소값이 가장 작은 정점 u를 선택.
8   T = T U { u } // 선택된 정점을 트리에 추가함.
    // 트리에 새로 추가된 정점의 인접 정점들의 출발 정점으로부터 최단 거리를 갱신한다.
9   for (v=0; v<n; v++)
10     if ( (v not in T & w[u,v] != 0 & d[u] < INF & d[u] + w[u,v] < d[v] ) {
11       d[v] = d[u] + w[u,v]
12       p[v] = u }
}
시간복잡도
- 기본연산 : 10번 조건 확인
- 9 ~ 12번의 반복문 내에서 기본 연산의 수행 횟수 = n
- 트리에 모든 정점이 포함되어야 하므로 O(n^2)




